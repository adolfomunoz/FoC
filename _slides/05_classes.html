---
title: Object Oriented Programming - Classes
---
<section>
	<section data-markdown>
		<textarea data-template>
		# Data abstraction
	
		In a big project using a particular data type you would need:
	
		- A data struture that represents such data type.
		- A set of functions that access such data type.
		</textarea>
	</section>

	<section>
		<h1>Data abstraction</h1>
		<pre><code class="hljs cpp" data-trim data-line-numbers="1-4|1|2-4">
		struct Rational { int num, den; };
		Rational create(int n, int d);
		Rational simplify(const Rational& r);
		Rational add(const Rational& r1, const Rational& r2);  
		</code></pre>
	</section>
	<section data-markdown>
		<textarea data-template>
		# Data abstraction

		- Following this methodology, you would be creating an **abstract** data type.
		- Your program would not need to directly access the data structure and only the functions.
		- You would not need to know the *implementation* of the data type.
		</textarea>
	</section>
	<section data-markdown>
		<textarea data-template>
		## Conclusion

		# Data abstraction
		is a
		# good idea	
		</textarea>
	</section>
</section>

<section>
	<section>
		<h2 class="r-fit-text">Object Oriented Programming = OOP</h2>
	</section>
	<section data-markdown>
		<textarea data-template>
		# OOP - Goals
	
		- Fully hide data structure implementation details.
		- Focus software design into data structures and their relations.
		</textarea>
	</section>
	<section data-markdown>
		<textarea data-template>
		# OOP - Naming

		- **Class**: data type
		- **Object**: variable with a value of a data type.
		- An **object** is an **instance** of a **class**.
		</textarea>
	</section>
	<section>
		<table width="100%"">
			<tr><th>Abstract type</th><th>Class</th></tr>
			<tr class="fragment">
				<td>Type and variable

					<pre><code class="hljs cpp" data-trim>
						struct String { ... };
						...
						String str;
					</code></pre>	

				</td>
				<td>Class and object

					<pre><code class="hljs cpp" data-trim>
						class String { ... };
						...
						String str;
					</code></pre>	

				</td>
			</tr>
			<tr class="fragment">
				<td>Functions
					<pre><code class="hljs cpp" data-trim>
						l = length(str);
						clear(str);
					</code></pre>	

				</td>
				<td>Methods (messages)

					<pre><code class="hljs cpp" data-trim>
						l = str.length();
						str.clear();
					</code></pre>	

				</td>
			</tr>		
			<tr class="fragment">
				<td>Function parameters
					<pre><code class="hljs cpp" data-trim>
						fill(str,16,'x');
						fill(str,4,'o');
					</code></pre>	

				</td>
				<td>Method parameters
					<pre><code class="hljs cpp" data-trim>
						str.fill(16,'x');
						str.fill(4,'o');
					</code></pre>	
				</td>
			</tr>				
		</table>
	</section>
	<section>
		<p>Are we just doing the same thing and just changing the syntax?</p><br/>

		<h1 class="fragment">YES</h1>
		<p class="fragment">(for now)</p>
	</section>
</section>

<section>
	<section>
		<h1>Classes</h1>

		<p>A class consists on <strong>attributes</strong> and <strong>methods</strong></p>
	</section>

	<section>
		<h1>Classes</h1>
		<pre><code class="hljs cpp" data-trim data-line-numbers="1-8|2-3|5-7">
			class Class {
				typeA1 attribute1;
				typeA2 attribute2;
				...
				typeM1 method(parameters) {
					implementation;
				}
			}; 
			</code></pre>
	</section>

	<section>
		<h1>Classes</h1>

		A <strong>class</strong> without methods is identical to a <strong>struct</strong>.

		<pre><code class="hljs cpp" data-trim data-line-numbers>
			class Class {
				typeA1 attribute1;
				typeA2 attribute2;
			}; 
			</code></pre>
	</section>

	<section>
		<table width="100%">
		<tr><th width="50%">Abstract type</th><th width="50%">Class</th></tr>
		<tr>
			<td width="50%"><pre><code class="hljs cpp" data-trim>
					struct String { 
						int size;
						char text[256]; 
					};

					void fill(String& str, int count, char c) {
						str.size = count;
						for (int i = 0; i < count; ++i)
							str.text[i] = c; 
					} 
					...
					String s;
					fill(s,16,'x');
				</code></pre>	
			</td>
			<td class="fragment" width="50%">
				<pre><code class="hljs cpp" data-trim>
					class String { 
						int size;
						char text[256]; 

						void fill(int count, char c) {
							this->size = count;
							for (int i = 0; i < count; ++i)
								this->text[i] = c; 
							} 
					};
					...
					String s;
					s.fill(16,'x');
				</code></pre>	
			</td>
		</tr>
	</table>		
	</section>
	<section data-markdown>
		<textarea data-template>
		# Classes

		- Methods are functions with *hidden* parameter `this`.
		- `this` is a pointer to the object that invokes the method.
		</textarea>
	</section>

	<section>
		<code>this</code> can be omitted if there are no ambiguities.

		<table width="100%">
		<tr>
			<td width="50%"><pre><code class="hljs cpp" data-trim>
				class String { 
					int size;
					char text[256]; 

					void fill(int count, char c) {
						this->size = count;
						for (int i = 0; i < count; ++i)
							this->text[i] = c; 
						} 
				};
				</code></pre>	
			</td>
			<td class="fragment" width="50%">
				<pre><code class="hljs cpp" data-trim>
					class String { 
						int size;
						char text[256]; 
	
						void fill(int count, char c) {
							size = count;
							for (int i = 0; i < count; ++i)
								text[i] = c; 
							} 
					};
				</code></pre>	
			</td>
		</tr>
	</table>		
	</section>
</section>