---
title: Data structures and classes
---
<section>
	<section data-auto-animate>
		<h1>Data structure</h1>

		<p>Group of data elements (members) of potentially different types 
			grouped together under one name</p>
	</section>
	<section data-auto-animate>
		<h1>Data structure</h1>

		<pre data-id="code-animation"><code class="hljs cpp" data-trim data-line-numbers="1-6|1|2-5|6">
			struct DataType { 
				member_type_01 member01; 
				member_type_02 member02; 
				member_type_03 member03; 
				...
			} data_variable1, data_variable2;
		</code></pre>
	</section>
	<section data-auto-animate>
		<h1>Data structure</h1>

		<pre data-id="code-animation"><code class="hljs cpp" data-trim data-line-numbers="1-8|1|2-5|7-8">
			struct DataType { 
				member_type_01 member01; 
				member_type_02 member02; 
				member_type_03 member03; 
				...
			};
			DataType data_variable1;
			DataType data_variable2;
		</code></pre>
	</section>
	<section>
		<h2>Designing data structures</h2>
		<ul>
			<li>Data structure should represent an entity with <strong>semantics</strong></li>
			<li>Members should aslo have a <strong>meaning</strong></li>
			<li>In general, <strong>avoid functional dependencies</strong> between members</li>
		</ul>
	</section>
	<section>
		<h2><code>struct</code> specification</h2>
		<pre><code class="hljs cpp" data-trim data-line-numbers">
			struct Car {
				string brand;
				string model;
				int year;
			};
		</code></pre>		
	</section>

	<section>
		<h2><code>struct</code> usage</h2>
		<pre><code class="hljs cpp" data-trim data-line-numbers>
			int main() {
				Car my_car;
				my_car.brand = "BMW";
				my_car.model = "X5";
				my_car.year = 1999;

				cout << my_car.brand << " " << 
					my_car.model << " " << 
					my_car.year << "\n";
			}
		</code></pre>		
	</section>

	<section>
		<h2><code>struct</code> usage (pointers)</h2>
		<pre><code class="hljs cpp" data-trim data-line-numbers>
			int main() {
				Car* my_car = new Car;
				my_car->brand = "BMW"; //Similar to (*my_car).brand;
				my_car->model = "X5";
				my_car->year = 1999;

				cout << my_car->brand << " " << 
					my_car->model << " " << 
					my_car->year << "\n";
				delete my_car;
			}
		</code></pre>		
	</section>
	<section>
		<h2>Designing data structures</h2>
		<ul>
			<li>Data structures enable some abstraction</li>
			<li>If a data structure can only be accessed through 
				functions, it can be used regardless of its implementation</li>
		</ul>
	</section>
	<section>
		<h2>vectorint.h</h2>
		<pre><code class="hljs cpp" data-trim data-line-numbers><script type="text/template">
			{%- include src/vectorint/vectorint.h -%}
		</script></code></pre>
	</section>
	<section>
		<h2>vectorint.cpp</h2>
		<pre><code class="hljs cpp" data-trim data-line-numbers><script type="text/template">
			{%- include src/vectorint/vectorint.cpp -%}
		</script></code></pre>
	</section>
	<section>
		<h2>main.cpp</h2>
		<pre><code class="hljs cpp" data-trim data-line-numbers><script type="text/template">
			{%- include src/vectorint/main.cpp -%}
		</script></code></pre>
	</section>
	<section>
		<h2>Designing data structures</h2>
		<ul>
			<li>Data structures can include members of other data structures</li>
			<li>Data structures can include members that are pointers to
				themselves (recursive structures)</li>
		</ul>
	</section>
	<section>
		<h2>listint.h</h2>
		<pre><code class="hljs cpp" data-trim data-line-numbers><script type="text/template">
			{%- include src/listint/listint.h -%}
		</script></code></pre>
	</section>
	<section>
		<h2>listint.cpp</h2>
		<pre><code class="hljs cpp" data-trim data-line-numbers><script type="text/template">
			{%- include src/listint/listint.cpp -%}
		</script></code></pre>
	</section>
	<section>
		<h2>main.cpp</h2>
		<pre><code class="hljs cpp" data-trim data-line-numbers><script type="text/template">
			{%- include src/listint/main.cpp -%}
		</script></code></pre>
	</section>
</section>
<section>
	<section data-markdown>
		<textarea data-template>
		# Data abstraction
	
		In a big project using a particular data type you would need:
	
		- A data struture that represents such data type.
		- A set of functions that access such data type.
		</textarea>
	</section>

	<section>
		<h1>Data abstraction</h1>
		<pre><code class="hljs cpp" data-trim data-line-numbers="1-4|1|2-4">
		struct Rational { int num, den; };
		Rational create(int n, int d);
		Rational simplify(const Rational& r);
		Rational add(const Rational& r1, const Rational& r2);  
		</code></pre>
	</section>
	<section data-markdown>
		<textarea data-template>
		# Data abstraction

		- Following this methodology, you would be creating an **abstract** data type.
		- Your program would not need to directly access the data structure and only the functions.
		- You would not need to know the *implementation* of the data type.
		</textarea>
	</section>
	<section data-markdown>
		<textarea data-template>
		## Conclusion

		# Data abstraction
		is a
		# good idea	
		</textarea>
	</section>
</section>

<section>
	<section>
		<h2 class="r-fit-text">Object Oriented Programming = OOP</h2>
	</section>
	<section data-markdown>
		<textarea data-template>
		# OOP - Goals
	
		- Fully hide data structure implementation details.
		- Focus software design into data structures and their relations.
		</textarea>
	</section>
	<section data-markdown>
		<textarea data-template>
		# OOP - Naming

		- **Class**: data type
		- **Object**: variable with a value of a data type.
		- An **object** is an **instance** of a **class**.
		</textarea>
	</section>
	<section>
		<table width="100%"">
			<tr><th>Abstract type</th><th>Class</th></tr>
			<tr class="fragment">
				<td>Type and variable

					<pre><code class="hljs cpp" data-trim>
						struct String { ... };
						...
						String str;
					</code></pre>	

				</td>
				<td>Class and object

					<pre><code class="hljs cpp" data-trim>
						class String { ... };
						...
						String str;
					</code></pre>	

				</td>
			</tr>
			<tr class="fragment">
				<td>Functions
					<pre><code class="hljs cpp" data-trim>
						l = length(str);
						clear(str);
					</code></pre>	

				</td>
				<td>Methods (messages)

					<pre><code class="hljs cpp" data-trim>
						l = str.length();
						str.clear();
					</code></pre>	

				</td>
			</tr>		
			<tr class="fragment">
				<td>Function parameters
					<pre><code class="hljs cpp" data-trim>
						fill(str,16,'x');
						fill(str,4,'o');
					</code></pre>	

				</td>
				<td>Method parameters
					<pre><code class="hljs cpp" data-trim>
						str.fill(16,'x');
						str.fill(4,'o');
					</code></pre>	
				</td>
			</tr>				
		</table>
	</section>
	<section>
		<p>Are we just doing the same thing and just changing the syntax?</p><br/>

		<h1 class="fragment">YES</h1>
		<p class="fragment">(for now)</p>
	</section>
</section>

<section>
	<section>
		<h1>Classes</h1>

		<p>A class consists on <strong>attributes</strong> and <strong>methods</strong> (or member functions)</p>
	</section>

	<section>
		<h1>Classes</h1>
		<pre><code class="hljs cpp" data-trim data-line-numbers="1-8|2-3|5-7">
			class Class {
				typeA1 attribute1;
				typeA2 attribute2;
				...
				typeM1 method(parameters) {
					implementation;
				}
			}; 
			</code></pre>
	</section>

	<section>
		<h1>Classes</h1>

		A <strong>class</strong> without methods is identical to a <strong>struct</strong>.

		<pre><code class="hljs cpp" data-trim data-line-numbers>
			class Class {
				typeA1 attribute1;
				typeA2 attribute2;
			}; 
			</code></pre>
	</section>

	<section>
		<table width="100%">
		<tr><th width="50%">Abstract type</th><th width="50%">Class</th></tr>
		<tr>
			<td width="50%"><pre><code class="hljs cpp" data-trim>
					struct String { 
						int size;
						char text[256]; 
					};

					void fill(String& str, int count, char c) {
						str.size = count;
						for (int i = 0; i < count; ++i)
							str.text[i] = c; 
					} 
					...
					String s;
					fill(s,16,'x');
				</code></pre>	
			</td>
			<td class="fragment" width="50%">
				<pre><code class="hljs cpp" data-trim>
					class String { 
						int size;
						char text[256]; 

						void fill(int count, char c) {
							this->size = count;
							for (int i = 0; i < count; ++i)
								this->text[i] = c; 
							} 
					};
					...
					String s;
					s.fill(16,'x');
				</code></pre>	
			</td>
		</tr>
	</table>		
	</section>
	<section data-markdown>
		<textarea data-template>
		# Classes

		- Methods are functions with *hidden* parameter `this`.
		- `this` is a pointer to the object that invokes the method.
		</textarea>
	</section>

	<section>
		<code>this</code> can be omitted if there are no ambiguities.

		<table width="100%">
		<tr>
			<td width="50%"><pre><code class="hljs cpp" data-trim>
				class String { 
					int size;
					char text[256]; 

					void fill(int count, char c) {
						this->size = count;
						for (int i = 0; i < count; ++i)
							this->text[i] = c; 
						} 
				};
				</code></pre>	
			</td>
			<td class="fragment" width="50%">
				<pre><code class="hljs cpp" data-trim>
					class String { 
						int size;
						char text[256]; 
	
						void fill(int count, char c) {
							size = count;
							for (int i = 0; i < count; ++i)
								text[i] = c; 
							} 
					};
				</code></pre>	
			</td>
		</tr>
	</table>		
	</section>
	<section>
		<h1>Visibility</h1>
		<ul>
			<li><b><code>private:</code> </b> Cannot access except from within the class</li>
			<li><b><code>public:</code> </b> Can access from everywhere</li>
		</ul>
		<p><b>Usually:</b> private attributes and public methods</p>
	</section>
	<section>
		<h1>Visibility</h1>
		<pre><code class="hljs cpp" data-trim data-line-numbers="1-11|2,5">
			class String { 
			private:
				int size;
				char text[256]; 
			public:
				void fill(int count, char c) {
					size = count;
					for (int i = 0; i < count; ++i)
						text[i] = c; 
					} 
			};
		</code></pre>	
	</section>
</section>

<section>
	<section>
		<h1>Constructors</h1>
		<p>Methods that define operations executed when creating an object</p>
	</section>

	<section>
		<p><strong>Constructors:</strong> for setting up default attribute values.</p>
		<pre><code class="hljs cpp" data-trim data-line-numbers="1-8|5-7">
			class Complex { 
			private:
				float _real, _imag; 
			public:
				Complex() {
					_real = _imag = 0;
				} 
			};
		</code></pre>
		<pre class="fragment"><code class="hljs cpp" data-trim data-line-numbers>
			Complex c; 
			// c._real = 0; c._image = 0;
			Complex* pc = new Complex;
			// pc->_real = 0; pc->_imag = 0;
		</code></pre>		
	</section>
	<section>
		<p><strong>Constructors:</strong> for setting up parametrized attribute values regardless of visibility.</p>
		<pre><code class="hljs cpp" data-trim data-line-numbers="1-8|5-7">
			class Complex { 
			private:
				float _real, _imag; 
			public:
				Complex(float real, float imag) {
					_real = real; _imag = imag;
				} 
			};
		</code></pre>
		<pre class="fragment"><code class="hljs cpp" data-trim data-line-numbers>
			// Complex c;  Complex* pc = new Complex <-- Can't do these
			Complex c(1,0); 
			//c._real=1; c._imag=0;
			Complex* pc = new Complex(1,0);
			// pc->_real = 1; pc->_imag = 0;
		</code></pre>		
	</section>

	<section data-auto-animate>
		<p>What happens when using classes as attributes?</p>
		<pre><code class="hljs cpp" data-trim data-line-numbers>
			class ElectromagneticWave {
			private:
				Complex phasor_vertical, phasor_horizontal;
			public:
				ElectromagneticWave() {
					phasor_vertical = Complex(0,-1);
					phasor_horizontal = Complex(1,0);
				} 
			} 
		</code></pre>
		<p>Does not compile if <code>Complex()</code> does not exist (needs to construct attributes)</p>
	</section>

	<section data-auto-animate>
		<p>What happens when using classes as attributes?</p>
		<pre><code class="hljs cpp" data-trim data-line-numbers>
			class ElectromagneticWave {
			private:
				Complex phasor_vertical, phasor_horizontal;
			public:
				ElectromagneticWave() :
					phasor_vertical(0,-1), phasor_horizontal(1,0) {} 
		</code></pre>
		<p>It actually invokes the constructores.</p>
	</section>


	<section>
		<p><strong>Constructors:</strong> more versatile with default parameter values.</p>
		<pre><code class="hljs cpp" data-trim data-line-numbers="1-8|5">
			class Complex { 
			private:
				float _real, _imag; 
			public:
				Complex(float real = 0, float imag = 0) {
					_real = real; _imag = imag;
				} 
			};
		</code></pre>
		<pre class="fragment"><code class="hljs cpp" data-trim data-line-numbers>
			Complex c1; // c1._real=0; c._imag=0;
			Complex c2(1,1); // c2._real=1; c2._imag=1;
			Complex c3(-1);  // c3._real=-1; c3._imag=0;
			Complex c4 = 2;  // c4._real=2; c4._imag=0;
		</code></pre>		
	</section>

	<section>
		<p><strong>Constructors:</strong> can be used to reserve resources (such as memory)</p>
		<pre><code class="hljs cpp" data-trim data-line-numbers="1-9|6-8">
			class VectorInt { 
			private:
				int* data;
				int size;
			public:
				VectorInt(int s) {
					size = s; data = new int[s]; 
				} 
			};
		</code></pre>
		<pre class="fragment"><code class="hljs cpp" data-trim data-line-numbers>
		{		
			VectorInt vi(128);
			...
		}	
		</code></pre>
		<p class="fragment">What about freeing that memory?</p>		
	</section>
</section>

<section>
	<section>
		<h1>Destructors</h1>
		<p>Methods that define operations executed when object dissappears from memory</p>
	</section>
	
	<section data-auto-animate>
		<p><strong>Destructors</strong></p>
		<pre><code class="hljs cpp" data-trim data-line-numbers="1-9|6-8">
			class VectorInt { 
			private:
				int* data;
				int size;
			public:
				VectorInt(int s) {
					size = s; data = new int[s]; 
				} 
			};
		</code></pre>
		<pre><code class="hljs cpp" data-trim data-line-numbers>
		{		
			VectorInt vi(128);
			...
		} // vi dissappears here
		</code></pre>
	</section>
	<section data-auto-animate>
		<p><strong>Destructors</strong></p>
		<pre><code class="hljs cpp" data-trim data-line-numbers="1-12|9-11">
			class VectorInt { 
			private:
				int* data;
				int size;
			public:
				VectorInt(int s) {
					size = s; data = new int[s]; 
				} 
				~VectorInt() {
					delete[] data; 
				} 	
			};
		</code></pre>
		<pre><code class="hljs cpp" data-trim data-line-numbers>
		{		
			VectorInt vi(128);
			...
		} // vi dissappears here
		</code></pre>
		<p class="fragment">The data is now deleted seamlessly</p>
	</section>
</section>

<section>
	<section>
		<h1>Operator overloading</h1>
		<p>Methods with special names are interpreted as operators.</p>
	</section>

	<section>
		<p><strong>Operators:</strong> can be defined as methods with special names</p>
		<pre><code class="hljs cpp" data-trim data-line-numbers="1-11|8-10">
			class Complex { 
			private:
				float _real, _imag; 
			public:
				Complex(float real = 0, float imag = 0) {
					_real = real; _imag = imag;
				} 
				Complex operator+(const Complex& that) const {
					return Complex(this->_real+that._real,this->_image+that._image);
				} 
			};
		</code></pre>
	</section>
	<section>
		<p><strong>Operators:</strong> some of them can only be functions</p>
		<pre><code class="hljs cpp" data-trim data-line-numbers="1-13|11-13">
			class Complex { 
			private:
				float _real, _imag; 
			public:
				Complex(float real = 0, float imag = 0) {
					_real = real; _imag = imag;
				} 
				float real() const { return _real; }  
				float imag() const { return _imag; }  
			};
			std::ostream& operator<<(std::ostream& os, const Complex& c) {
				os<<c.real()<<" + "<<c.imag()<<"i"; return os;
			} 
		</code></pre>
	</section>
	<section>
		<p><strong>Operators:</strong> some of them can only be methods</p>
		<pre><code class="hljs cpp" data-trim data-line-numbers="1-13|11-13">
			class VectorInt { 
			private:
				int* data;
				int size;
			public:
				VectorInt(int s) {
					size = s; data = new int[s]; 
				} 
				~VectorInt() {
					delete[] data; 
				} 	
				int& operator[](int i) { return data[i]; }  
				int operator[](int i) const { return data[i]; }  
			};
		</code></pre>
	</section>
</section>